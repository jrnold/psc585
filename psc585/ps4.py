import os
from os import path

import pytave
import scipy as sp
from scipy import io

_MFILES = path.abspath(path.join(path.dirname(__file__), "..", "octave"))
pytave.addpath(_MFILES)

def _pp(i, ai):
    """Column in Pp for ai"""
    return (i * 2) + ai

class FinalModel(object):
    """

    Properties
    -----------------

    delta : float
        Discount factor of the government and provinces
    g1oversigma :
        Parameter :math:`\sigma_g`
    k : int
        Number of provinces
    m : int
        Number of states that provinces can take, :math:`2^k`
    n : int
        Number of states, :math:`k 2^k`
    x : ndarray, shape (k, )
        Variable correlated with the wealth generated by each province
    y : ndarray, shape (k, )
        Variable correlated with the cost of war to each province
    wg : float
        Government war cost
    D : ndarray, shape (k, k)
        Matrix of distances between provinces
    S : ndarray, shape (n, k)
        transition matrix
    data : ndarray, shape (T, k + 2)
        Data, as in FinalData.mat. The first column records the state :math:`l, s`,
        enumerated according to the order of the coordinates. The last column contains
        the actions of the government. The :math:`k` middle columns contain the
        actions of the provinces.

    """
    def __init__(self, **kwargs):
        for k, v in kwargs.iteritems():
            self.__setattr__(k, v)

    _properties = ['delta',
                   'g1oversigma',
                   'k',
                   'm',
                   'n',
                   'x',
                   'y',
                   'wg',
                   'D',
                   'S']

    @classmethod
    def from_mat(cls, model, data):
        """ Instantiate class from .mat files

        Parameters
        -------------
        model : string
              Path to FinalModel.dat
        data : string
              Path to FinalData.mat

        Returns
        ---------
        obj : FinalModel
              Instance of the FinalModel class

        """
        final_model = io.loadmat(model, squeeze_me = True)['model']
        keys = final_model.dtype.names
        kwargs = {}
        for k in keys:
            kwargs[k] = final_model[[k]][0]
        for k in ['k', 'm', 'n']:
            kwargs[k] = int(kwargs[k])
        for k in ['delta', 'wg', 'g1oversigma']:
            kwargs[k] = float(kwargs[k])
        kwargs['S'] = kwargs['S'].astype(int)
        final_data = io.loadmat(data)['data']
        kwargs['data'] = final_data
        return cls(**kwargs)

    def model(self):
        """Return model dict"""
        return dict((k, self.__getattribute__(k)) for k in self._properties)  

    def new_p(self, Pp, Pg, theta):
        """ Calculate transition probabilities

        Pp : ndarray, shape (n, k)
             Conditional choice probabilities for provinces
        Pg : ndarray, shape (n, 2 k)
             Conditional choice probabilities for the government
        theta : ndarray, shape (5, )
             Parameters

        Returns
        ---------
        Pp : ndarray, shape (n, k)
             New conditional choice probabilities for provinces
        Pg : ndarray, shape (n, 2 k)
             New conditional choice probabilities for the government

        Notes
        -----------

        Takes conditional choice probabilities :math:`P` and :math:`\theta`
        as an input and returns new conditional choice values.
        This is the mapping :math:`\Psi` in part (c) of the assignment.

        This is a wrapper for the matlab function **NewP**.
        
        """
        theta = sp.atleast_2d(theta)
        return pytave.feval(2, "NewP", Pp, Pg, theta, self.model())

    def phigprov(self, Pp, Pg, theta):
        """ Calculate transition probabilities

        Parameters
        ------------
        Pp : ndarray, shape (n, k)
             Conditional choice probabilities for provinces
        Pg : ndarray, shape (n, 2 k)
             Conditional choice probabilities for the government
        theta : ndarray, shape (5, )
             Parameters

        Returns
        ---------
        V : ndarray
            Observable state values

        Notes
        -----------

        Takes conditional choice probabilities :math:`P` and :math:`\theta`
        as an input and returns values :math:`V^`.
        This is the mapping :math:`\Phi` in part (b) of the assignment.

        This is a wrapper for the matlab function **Phigprov**.
        
        """
        theta = sp.atleast_2d(theta)
        return pytave.feval(1, "Phigprov", Pp, Pg, theta, self.model())[0]

    def ptilde(self, Pp, Pg):
        """ Calculate transition probabilities

        Parameters
        ------------
        Pp : ndarray, shape (n, k)
             Conditional choice probabilities for provinces
        Pg : ndarray, shape (n, 2 k)
             Conditional choice probabilities for the government

        Returns
        ---------
        P : ndarray
            Transition probability matrix

        Notes
        -----------

        Takes conditional choice probabilities :math:`P` as an input and
        returns the transition matrix :math:`\tilde{P}`.

        This is a wrapper for the matlab function **Ptilde**.
        
        """
        return pytave.feval(1, "Ptilde", Pp, Pg, self.model())[0]

    def ptilde_i(self, Pp, Pg, i, ai):
        """ Transition probabilities conditional on player i's action

        Parameters
        ------------
        Pp : ndarray, shape (n, k)
             Conditional choice probabilities for provinces
        Pg : ndarray, shape (n, 2 k)
             Conditional choice probabilities for the government
        i : int, 1 to k
            Province 
        ai : int, bool
            Province i's action :math:`a_i`

        Returns
        ---------
        P : ndarray
            Transition probability matrix

        Notes
        ---------

        This method calculates :math:`\tilde{P}^P_i(a_i)`, the
        transition matrix with probabilities :math:`\tilde{p}^P_i(l', s' | l, s, a_i)`.

        This is calculated by taking the matrix Pp, and replacing the
        columns corresponding to player :math:`i`'s actions assuming that player :math:`i`
        plays action :math:`a_i`.  This new probability matrix is then used
        as an input to :py:func:`psc585.PS4.FinalModel.ptilde`.
        
        """
        Ppi = Pp.copy()
        Ppi[: , _pp(i, 0)] = float((1 - ai) % 2)   # =1 when ai=0, =1 when ai=1
        Ppi[: , _pp(i, 1)] = float((2 - ai) % 2)   # =1 when ai=1, =0, when ai=0
        P = self.ptilde(Ppi, Pg)
        return P

    def y_d(self):
        """ Data matrix Y_d

        Returns
        --------
        y : ndarray, shape (k*T, )
            Matrix :math:`Y_d`


        Notes
        ----------

        Calculates the :math:`k * T \times 1` matrix :math:`Y_d` in part (e) of
        the assignment. 

        """
        y = self.data[:, 1:-1].ravel("F")
        return y

    def E_i(self, Pp, Pg):
        """ Calculate E_i^P
        """
        pass

    def Z_i(self, Pp, Pg):
        """ Calculate Z_i^P
        """
        pass

    def C_d(self):
        """ Calculate C_d """
        pass

    def W_d(self):
        """ Calculate W_d """
        pass
    

    
